//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

#include <opencv2/core/core.hpp>
#include <opencv2/core/operations.hpp>
#include <opencv2/core/types_c.h>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/imgproc/types_c.h>
#include <SendImageAnswHandler.hh>
#include <iostream>
#include <vector>

#include "../../../CommHoleLocalizer/smartsoft/src/CommHoleLocalizer/BoundingBox.hh"
#include "../../../CommHoleLocalizer/smartsoft/src-gen/CommHoleLocalizer/BoundingBoxCore.hh"
#include "../../../CommHoleLocalizer/smartsoft/src-gen/CommHoleLocalizer/HolesCore.hh"
#include "../../../CommHoleLocalizer/smartsoft/src-gen/CommHoleLocalizer/ImageDirCore.hh"

//#include <smartNSAdapterACE.hh>
using namespace std;
using namespace cv;



SendImageAnswHandler::SendImageAnswHandler(Smart::IQueryServerPattern<CommHoleLocalizer::ImageDir, CommHoleLocalizer::Holes, SmartACE::QueryId>* server)
:	SendImageAnswHandlerCore(server)
{

}

SendImageAnswHandler::~SendImageAnswHandler()
{

}


void SendImageAnswHandler::handleQuery(const SmartACE::QueryId &id, const CommHoleLocalizer::ImageDir& request)
{
	CommHoleLocalizer::Holes answer;

//	CommHoleLocalizer:: BoundingBox s;
//	s.setX(5);
//	answer.resizeList(1);
//	answer.setListElemAtPos(0, s);

	std::string filePath = request.getDirectory();
	std:: cout << filePath << std::endl;

//	std::vector <Point> centres = findHoles(filePath);
//	int size= centres.size();
//	answer.resizeList(size);
//	for (int i=0 ; i<size ; i++) {
//		CommHoleLocalizer::BoundingBox newBox;
//		newBox.setX(centres[i].x);
//		newBox.setY(centres[i].y);
//		answer.setListElemAtPos(i, newBox );
//	}


	answer= SendImageAnswHandler::findHoles(filePath);
	cout << "size of object at end = " << answer.getListSize() << std::endl;
	// implement your query handling logic here and fill in the answer object
	this->server->answer(id, answer);
}

CommHoleLocalizer::Holes SendImageAnswHandler::findHoles(std::string filePath){
	CommHoleLocalizer::Holes result;

//	vector <Point> centres;
	Mat tmp,thr;

	Mat src=cv::imread(filePath,1);
	cvtColor(src,tmp,CV_BGR2GRAY);
	threshold(tmp,thr,200,255,THRESH_BINARY_INV);
//	namedWindow("thr",0);
//	imshow("thr",thr);

	std::vector< vector <Point> > contours; // Vector for storing contour
	std::vector< Vec4i > hierarchy;
	Mat dst(src.rows,src.cols,CV_8UC1,Scalar::all(0)); //create destination image
	int count=0;
	int cx, cy;
	findContours( thr, contours, hierarchy,CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE ); // Find the contours in the image
	for( int i = 0; i< contours.size(); i=hierarchy[i][0] ) // iterate through each contour.
	{

		Rect r= boundingRect(contours[i]);
		if(hierarchy[i][2]<0){
//			rectangle(src,Point(r.x,r.y), Point(r.x+r.width,r.y+r.height), Scalar(0,0,255),3,8,0);
			count++;
			cx= (r.x+r.width)/2;
			cy= (r.y+r.height)/2;
//			Point centre = Point(cx,cy);
//			centres.push_back(centre);
//
			CommHoleLocalizer::BoundingBox newBox;
			newBox.setX(cx);
			newBox.setY(cy);
			newBox.setWidth(r.width);
			newBox.setHeight(r.height);
			result.resizeList(count);

			result.setListElemAtPos(count-1, newBox );

		}
	}
	cout<<"Number of contour = "<<count<<endl;
//	cout << "size of object at end = " << result.getListSize() << endl;
//	namedWindow("src",0);
//	imshow("src",src);
//	namedWindow("contour",0);
//	imshow("contour",src);
//    waitKey(0);
	return result;
}

